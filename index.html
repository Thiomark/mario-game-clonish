<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Plumber Bros: World 1-1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #5c94fc;
        }

        canvas {
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #5c94fc;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 20px;
            color: white;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            display: flex;
            justify-content: space-between;
            width: 100%;
            box-sizing: border-box;
        }

        #controls {
            display: none;
            width: 100%;
            height: 150px;
            pointer-events: auto;
            padding-bottom: 20px;
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            user-select: none;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.6);
        }

        .d-pad {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: flex;
            gap: 20px;
        }

        .action-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
        }

        @media (hover: none) and (pointer: coarse) {
            #controls { display: block; }
        }

        #start-screen, #msg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
            text-align: center;
        }

        #msg-overlay {
            display: none;
            z-index: 20;
        }

        h1 { font-size: 40px; margin-bottom: 10px; text-shadow: 4px 4px 0 #E70012; }
        p { font-size: 18px; margin-bottom: 20px; max-width: 600px; line-height: 1.4; }

        .btn {
            padding: 15px 30px;
            font-size: 20px;
            font-family: inherit;
            background: #E70012;
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 0 #8B0000;
            margin: 10px;
            min-width: 200px;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .btn-ai { background: #673AB7; box-shadow: 0 4px 0 #311B92; }

        #ai-controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
        }

        input[type="text"] {
            padding: 10px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 10px;
            font-family: inherit;
            border: 2px solid #673AB7;
            background: #333;
            color: white;
        }

        .loader {
            display: none;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #673AB7;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div>SCORE <br><span id="scoreVal">000000</span></div>
            <div>WORLD <br>1-1</div>
            <div>TIME <br><span id="timeVal">400</span></div>
        </div>

        <div id="controls">
            <div class="d-pad">
                <div class="touch-btn" id="btn-left">←</div>
                <div class="touch-btn" id="btn-right">→</div>
            </div>
            <div class="action-btn">
                <div class="touch-btn" id="btn-jump">A</div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>SUPER PLUMBER</h1>
        <p>Arrow Keys to Move • Space to Jump</p>

        <button class="btn" onclick="startGame(false)">PLAY CLASSIC</button>

        <div id="ai-controls">
            <div style="margin-bottom: 5px; color: #B39DDB;">✨ Create Custom Level with Gemini ✨</div>
            <input type="text" id="ai-prompt" placeholder="e.g. 'A hard level with lots of fire bars'">
            <button class="btn btn-ai" onclick="startGame(true)">GENERATE LEVEL</button>
            <div class="loader" id="loading-spinner"></div>
            <div id="loading-text" style="display:none; color: #B39DDB; margin-top:10px;">Constructing level...</div>
        </div>
    </div>

    <div id="msg-overlay">
        <h1 id="msg-title">GAME OVER</h1>
        <p id="msg-text">...</p>
        <div class="loader" id="msg-loader"></div>
        <button class="btn" onclick="resetToMenu()">MAIN MENU</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
const TILE_SIZE = 32;
const GRAVITY_Y = 1200;
const MOVE_SPEED = 190;
const JUMP_SPEED = -480;

const CLASSIC_LEVEL = `
................................................................................................................................
....................................................................................................F.....
................................................................................................................................
....................................................................................................f.....
................................................................................................................................
....................................................................................................f.....
................................................................................................................................
....................................................................................................f.....
................................................................................................................................
....................................................................................................f.....
................................................................................................................................
....................................................................................................f.....
................................................................................................................................
....................................................................................................f.....
................................................................................................................................
....................................................................................................f.....
................................................................................................................................
....................................................................................................f.....
..............................Q......................................Q.Q.Q................Q.....................................
............................................................................................S.......f.....
..............................B......................................B.B.B................B.....................................
...........................................................................................SS.......f.....
............................QB.BQ...................................BB.B.BB.....................................................
........................SSS...............................................................SSS.......f.....
................................................................................................................................
.......................SSSS..............................................................SSSS.......f.....
.........................................e.................................e........e.............................e...........e.
..e...................SSSSS.............................................................SSSSS.......f.....
................................................................................................................................
.....................SSSSSS............................................................SSSSSS.......f.....
........................................lr........................lr..........................lr................................
....................SSSSSSS...........................................................SSSSSSS.......f.....
........................................LR........................LR..........................LR................................
...................SSSSSSSS..........................................................SSSSSSSS.......f.....
GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG..GGGGGGGGGGGGGGGGGGGGGG..GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG..GGGGGGGGGGGGGG
GGGGGGGGGGGGGGGGGGGGGGGGGGG..........................................................GGGGGGGGGGGGGGGGGGGGG
GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG..GGGGGGGGGGGGGGGGGGGGGG..GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG..GGGGGGGGGGGGGG
GGGGGGGGGGGGGGGGGGGGGGGGGGG..........................................................GGGGGGGGGGGGGGGGGGGGG
`;

let apiKey = "";
let currentLevelString = CLASSIC_LEVEL;
let score = 0;
let timeLeft = 400;
let gameState = 'START';
let phaserGame;

const keyState = { left: false, right: false, jump: false };

function updateHUD() {
    document.getElementById('scoreVal').textContent = score.toString().padStart(6, '0');
    document.getElementById('timeVal').textContent = Math.max(0, Math.floor(timeLeft)).toString();
}

async function callGemini(userPrompt, systemInstruction) {
    if (!apiKey) return null;

    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
    const payload = {
        contents: [{ parts: [{ text: userPrompt }] }],
        systemInstruction: { parts: [{ text: systemInstruction }] }
    };

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text;
    } catch (error) {
        console.error('Gemini API Failed:', error);
        return null;
    }
}

async function generateAILevel(theme) {
    const spinner = document.getElementById('loading-spinner');
    const text = document.getElementById('loading-text');
    spinner.style.display = 'block';
    text.style.display = 'block';

    const systemPrompt = `
    You are a level designer for a 2D Mario-style platformer.
    You MUST output a valid level grid using ONLY the characters in the legend below.
    The output must be a single text block with no markdown formatting.

    LEGEND:
    . = Air (Empty space)
    G = Ground block
    B = Breakable Brick
    Q = Question Block (Powerup/Coin)
    e = Goomba Enemy
    l,r,L,R = Pipe pieces (l=top-left, r=top-right, L=btm-left, R=btm-right). Must always be placed in a 2x2 square.
    S = Unbreakable Stone (used for stairs)
    F,f = Flag (F=top ball, f=pole). MUST be at the very end.

    CONSTRAINTS:
    1. The grid MUST be exactly 19 rows high.
    2. The grid should be between 150 and 200 columns wide.
    3. The bottom 2 rows (rows 17 and 18, 0-indexed) MUST be 'G' (Ground) to prevent falling, except for optional pits.
    4. Start the player area (left side) relatively safe.
    5. Place a Flag pole (F on top of f's) at the far right.
    6. Ensure the level is playable (jumps are possible).

    Output ONLY the raw string grid.
    `;

    const prompt = `Generate a level with the following theme/description: "${theme}".`;
    const result = await callGemini(prompt, systemPrompt);

    spinner.style.display = 'none';
    text.style.display = 'none';

    if (result) {
        let cleanResult = result.replace(/```/g, '').trim();
        return cleanResult;
    } else {
        alert('AI Generation failed. Loading Classic World 1-1.');
        return null;
    }
}

async function generateNarratorComment(type, context) {
    const systemPrompt = `
    You are a snarky, retro video game announcer/narrator.
    Keep it short (max 1 sentence).
    Be funny but encouraging.
    If the player died, roast them slightly.
    If they won, congratulate them with 80s slang.
    `;

    const prompt = type === 'die'
        ? `The player just died by ${context}. Roast them.`
        : `The player just beat the level with score ${context}. Congratulate them.`;

    return await callGemini(prompt, systemPrompt);
}

class MainScene extends Phaser.Scene {
    constructor() {
        super('MainScene');
        this.levelRows = [];
        this.platforms = null;
        this.flagPole = null;
        this.goombas = null;
        this.player = null;
        this.cursors = null;
        this.jumpHeld = false;
    }

    create(data) {
        this.levelRows = (data.levelString || CLASSIC_LEVEL).trim().split('\n');
        this.platforms = this.physics.add.staticGroup();
        this.flagPole = this.physics.add.staticGroup();
        this.goombas = this.physics.add.group();
        this.cursors = this.input.keyboard.createCursorKeys();

        const cols = this.levelRows[0]?.length || 1;
        const height = this.levelRows.length || 1;
        this.physics.world.setBounds(0, 0, cols * TILE_SIZE, height * TILE_SIZE);

        this.createTextures();
        this.buildLevel();
        this.spawnPlayer();

        this.cameras.main.setBounds(0, 0, cols * TILE_SIZE, height * TILE_SIZE);
        this.cameras.main.startFollow(this.player, true, 0.15, 0.15);

        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.goombas, this.platforms);
        this.physics.add.collider(this.goombas, this.goombas);
        this.physics.add.overlap(this.player, this.goombas, this.handleEnemyCollision, undefined, this);
        this.physics.add.overlap(this.player, this.flagPole, this.handleWin, undefined, this);

        this.time.addEvent({
            delay: 1000,
            loop: true,
            callback: () => {
                if (gameState !== 'PLAYING') return;
                timeLeft -= 1;
                if (timeLeft <= 0) {
                    this.handleDeath('time ran out');
                }
                updateHUD();
            }
        });

        gameState = 'PLAYING';
    }

    update() {
        if (gameState !== 'PLAYING') return;
        const body = this.player.body;
        const onGround = body.blocked.down;

        if (this.cursors.left.isDown || keyState.left) {
            body.setVelocityX(-MOVE_SPEED);
        } else if (this.cursors.right.isDown || keyState.right) {
            body.setVelocityX(MOVE_SPEED);
        } else {
            body.setVelocityX(0);
        }

        const jumpPressed = this.cursors.up.isDown || this.cursors.space?.isDown || keyState.jump;
        if (jumpPressed && onGround && !this.jumpHeld) {
            body.setVelocityY(JUMP_SPEED);
            this.jumpHeld = true;
        }
        if (!jumpPressed) {
            this.jumpHeld = false;
        }

        this.goombas.children.iterate(goomba => {
            if (!goomba || !goomba.body) return;
            if (goomba.body.blocked.left) {
                goomba.body.setVelocityX(50);
            } else if (goomba.body.blocked.right) {
                goomba.body.setVelocityX(-50);
            }
        });
    }

    createTextures() {
        const createSolid = (key, color) => {
            const g = this.make.graphics({ x: 0, y: 0, add: false });
            g.fillStyle(color, 1);
            g.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            g.generateTexture(key, TILE_SIZE, TILE_SIZE);
            g.destroy();
        };

        createSolid('ground', 0x8B4513);
        createSolid('brick', 0xC45A24);
        createSolid('question', 0xE6B800);
        createSolid('stone', 0x6D6D6D);
        createSolid('pipe', 0x2E8B57);
        createSolid('flag', 0xFFFFFF);
        createSolid('playerTex', 0xCD853F);
        createSolid('goombaTex', 0x7B3F00);
    }

    buildLevel() {
        this.levelRows.forEach((row, y) => {
            [...row].forEach((char, x) => {
                const worldX = x * TILE_SIZE + TILE_SIZE / 2;
                const worldY = y * TILE_SIZE + TILE_SIZE / 2;

                if (char === 'G' || char === 'B' || char === 'Q' || char === 'S') {
                    const tex = char === 'G' ? 'ground' : char === 'B' ? 'brick' : char === 'Q' ? 'question' : 'stone';
                    const block = this.add.sprite(worldX, worldY, tex);
                    this.physics.add.existing(block, true);
                    this.platforms.add(block);
                } else if (['l','r','L','R'].includes(char)) {
                    const pipe = this.add.sprite(worldX, worldY, 'pipe');
                    this.physics.add.existing(pipe, true);
                    this.platforms.add(pipe);
                } else if (char === 'f' || char === 'F') {
                    const flagPiece = this.add.sprite(worldX, worldY, 'flag');
                    this.physics.add.existing(flagPiece, true);
                    this.flagPole.add(flagPiece);
                } else if (char === 'e') {
                    const enemy = this.add.sprite(worldX, worldY, 'goombaTex');
                    this.physics.add.existing(enemy);
                    enemy.body.setCollideWorldBounds(true);
                    enemy.body.setBounce(1, 0);
                    enemy.body.setVelocityX(-50);
                    this.goombas.add(enemy);
                }
            });
        });
    }

    spawnPlayer() {
        const safeCol = 2;
        let spawnY = TILE_SIZE * 4;
        for (let y = this.levelRows.length - 1; y >= 0; y--) {
            const char = this.levelRows[y][safeCol] || '.';
            if (char !== '.') {
                spawnY = y * TILE_SIZE - TILE_SIZE;
                break;
            }
        }

        this.player = this.add.sprite(TILE_SIZE * safeCol + TILE_SIZE, spawnY, 'playerTex');
        this.physics.add.existing(this.player);
        this.player.body.setCollideWorldBounds(true);
        this.player.body.setSize(TILE_SIZE - 6, TILE_SIZE - 4);
        this.player.body.setOffset(3, 2);
    }

    handleEnemyCollision(player, goomba) {
        if (!player.body || !goomba.body) return;
        if (player.body.velocity.y > 50) {
            goomba.disableBody(true, true);
            score += 100;
            player.body.setVelocityY(JUMP_SPEED * 0.5);
            updateHUD();
        } else {
            this.handleDeath('a Goomba');
        }
    }

    handleDeath(reason) {
        if (gameState !== 'PLAYING') return;
        gameState = 'GAME_OVER';
        this.physics.pause();
        showOverlay('GAME OVER', `You were defeated by ${reason}.`, 'die', score);
    }

    handleWin() {
        if (gameState !== 'PLAYING') return;
        gameState = 'WIN';
        this.physics.pause();
        showOverlay('LEVEL COMPLETE', 'Nice job! You reached the flag.', 'win', score);
    }
}

function bootGame() {
    const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        canvas: document.getElementById('gameCanvas'),
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: '#5c94fc',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: GRAVITY_Y },
                debug: false
            }
        },
        scene: [MainScene]
    };

    phaserGame = new Phaser.Game(config);

    window.addEventListener('resize', () => {
        phaserGame.scale.resize(window.innerWidth, window.innerHeight);
    });
}

async function startGame(useAI) {
    const promptInput = document.getElementById('ai-prompt');
    const startScreen = document.getElementById('start-screen');
    startScreen.style.display = 'none';
    score = 0;
    timeLeft = 400;
    updateHUD();

    if (useAI) {
        const theme = promptInput.value || 'A classic level with pipes and bricks';
        const level = await generateAILevel(theme);
        currentLevelString = level || CLASSIC_LEVEL;
    } else {
        currentLevelString = CLASSIC_LEVEL;
    }

    if (!phaserGame) {
        bootGame();
        phaserGame.events.once(Phaser.Core.Events.READY, () => phaserGame.scene.start('MainScene', { levelString: currentLevelString }));
    } else {
        phaserGame.scene.start('MainScene', { levelString: currentLevelString });
    }
    document.getElementById('msg-overlay').style.display = 'none';
    gameState = 'PLAYING';
}

function resetToMenu() {
    document.getElementById('msg-overlay').style.display = 'none';
    document.getElementById('start-screen').style.display = 'flex';
    if (phaserGame) {
        phaserGame.scene.stop('MainScene');
    }
    gameState = 'START';
}

async function showOverlay(title, message, type, context) {
    const overlay = document.getElementById('msg-overlay');
    const msgTitle = document.getElementById('msg-title');
    const msgText = document.getElementById('msg-text');
    const loader = document.getElementById('msg-loader');

    msgTitle.textContent = title;
    msgText.textContent = message;
    overlay.style.display = 'flex';

    if (apiKey) {
        loader.style.display = 'block';
        const aiText = await generateNarratorComment(type, context);
        loader.style.display = 'none';
        if (aiText) msgText.textContent = aiText;
    }
}

function setupTouchControls() {
    const addHoldListeners = (element, flag) => {
        element.addEventListener('touchstart', () => { keyState[flag] = true; });
        element.addEventListener('touchend', () => { keyState[flag] = false; });
        element.addEventListener('mousedown', () => { keyState[flag] = true; });
        element.addEventListener('mouseup', () => { keyState[flag] = false; });
        element.addEventListener('mouseleave', () => { keyState[flag] = false; });
    };

    addHoldListeners(document.getElementById('btn-left'), 'left');
    addHoldListeners(document.getElementById('btn-right'), 'right');
    addHoldListeners(document.getElementById('btn-jump'), 'jump');
}

setupTouchControls();
updateHUD();
</script>
</body>
</html>
